// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote/ethbackend.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remote_2fethbackend_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remote_2fethbackend_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_remote_2fethbackend_2eproto;
namespace remote {
class AddReply;
class AddReplyDefaultTypeInternal;
extern AddReplyDefaultTypeInternal _AddReply_default_instance_;
class ClientVersionReply;
class ClientVersionReplyDefaultTypeInternal;
extern ClientVersionReplyDefaultTypeInternal _ClientVersionReply_default_instance_;
class ClientVersionRequest;
class ClientVersionRequestDefaultTypeInternal;
extern ClientVersionRequestDefaultTypeInternal _ClientVersionRequest_default_instance_;
class EtherbaseReply;
class EtherbaseReplyDefaultTypeInternal;
extern EtherbaseReplyDefaultTypeInternal _EtherbaseReply_default_instance_;
class EtherbaseRequest;
class EtherbaseRequestDefaultTypeInternal;
extern EtherbaseRequestDefaultTypeInternal _EtherbaseRequest_default_instance_;
class GetHashRateReply;
class GetHashRateReplyDefaultTypeInternal;
extern GetHashRateReplyDefaultTypeInternal _GetHashRateReply_default_instance_;
class GetHashRateRequest;
class GetHashRateRequestDefaultTypeInternal;
extern GetHashRateRequestDefaultTypeInternal _GetHashRateRequest_default_instance_;
class GetWorkReply;
class GetWorkReplyDefaultTypeInternal;
extern GetWorkReplyDefaultTypeInternal _GetWorkReply_default_instance_;
class GetWorkRequest;
class GetWorkRequestDefaultTypeInternal;
extern GetWorkRequestDefaultTypeInternal _GetWorkRequest_default_instance_;
class MiningReply;
class MiningReplyDefaultTypeInternal;
extern MiningReplyDefaultTypeInternal _MiningReply_default_instance_;
class MiningRequest;
class MiningRequestDefaultTypeInternal;
extern MiningRequestDefaultTypeInternal _MiningRequest_default_instance_;
class NetVersionReply;
class NetVersionReplyDefaultTypeInternal;
extern NetVersionReplyDefaultTypeInternal _NetVersionReply_default_instance_;
class NetVersionRequest;
class NetVersionRequestDefaultTypeInternal;
extern NetVersionRequestDefaultTypeInternal _NetVersionRequest_default_instance_;
class ProtocolVersionReply;
class ProtocolVersionReplyDefaultTypeInternal;
extern ProtocolVersionReplyDefaultTypeInternal _ProtocolVersionReply_default_instance_;
class ProtocolVersionRequest;
class ProtocolVersionRequestDefaultTypeInternal;
extern ProtocolVersionRequestDefaultTypeInternal _ProtocolVersionRequest_default_instance_;
class SubmitHashRateReply;
class SubmitHashRateReplyDefaultTypeInternal;
extern SubmitHashRateReplyDefaultTypeInternal _SubmitHashRateReply_default_instance_;
class SubmitHashRateRequest;
class SubmitHashRateRequestDefaultTypeInternal;
extern SubmitHashRateRequestDefaultTypeInternal _SubmitHashRateRequest_default_instance_;
class SubmitWorkReply;
class SubmitWorkReplyDefaultTypeInternal;
extern SubmitWorkReplyDefaultTypeInternal _SubmitWorkReply_default_instance_;
class SubmitWorkRequest;
class SubmitWorkRequestDefaultTypeInternal;
extern SubmitWorkRequestDefaultTypeInternal _SubmitWorkRequest_default_instance_;
class SubscribeReply;
class SubscribeReplyDefaultTypeInternal;
extern SubscribeReplyDefaultTypeInternal _SubscribeReply_default_instance_;
class SubscribeRequest;
class SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class TxRequest;
class TxRequestDefaultTypeInternal;
extern TxRequestDefaultTypeInternal _TxRequest_default_instance_;
}  // namespace remote
PROTOBUF_NAMESPACE_OPEN
template<> ::remote::AddReply* Arena::CreateMaybeMessage<::remote::AddReply>(Arena*);
template<> ::remote::ClientVersionReply* Arena::CreateMaybeMessage<::remote::ClientVersionReply>(Arena*);
template<> ::remote::ClientVersionRequest* Arena::CreateMaybeMessage<::remote::ClientVersionRequest>(Arena*);
template<> ::remote::EtherbaseReply* Arena::CreateMaybeMessage<::remote::EtherbaseReply>(Arena*);
template<> ::remote::EtherbaseRequest* Arena::CreateMaybeMessage<::remote::EtherbaseRequest>(Arena*);
template<> ::remote::GetHashRateReply* Arena::CreateMaybeMessage<::remote::GetHashRateReply>(Arena*);
template<> ::remote::GetHashRateRequest* Arena::CreateMaybeMessage<::remote::GetHashRateRequest>(Arena*);
template<> ::remote::GetWorkReply* Arena::CreateMaybeMessage<::remote::GetWorkReply>(Arena*);
template<> ::remote::GetWorkRequest* Arena::CreateMaybeMessage<::remote::GetWorkRequest>(Arena*);
template<> ::remote::MiningReply* Arena::CreateMaybeMessage<::remote::MiningReply>(Arena*);
template<> ::remote::MiningRequest* Arena::CreateMaybeMessage<::remote::MiningRequest>(Arena*);
template<> ::remote::NetVersionReply* Arena::CreateMaybeMessage<::remote::NetVersionReply>(Arena*);
template<> ::remote::NetVersionRequest* Arena::CreateMaybeMessage<::remote::NetVersionRequest>(Arena*);
template<> ::remote::ProtocolVersionReply* Arena::CreateMaybeMessage<::remote::ProtocolVersionReply>(Arena*);
template<> ::remote::ProtocolVersionRequest* Arena::CreateMaybeMessage<::remote::ProtocolVersionRequest>(Arena*);
template<> ::remote::SubmitHashRateReply* Arena::CreateMaybeMessage<::remote::SubmitHashRateReply>(Arena*);
template<> ::remote::SubmitHashRateRequest* Arena::CreateMaybeMessage<::remote::SubmitHashRateRequest>(Arena*);
template<> ::remote::SubmitWorkReply* Arena::CreateMaybeMessage<::remote::SubmitWorkReply>(Arena*);
template<> ::remote::SubmitWorkRequest* Arena::CreateMaybeMessage<::remote::SubmitWorkRequest>(Arena*);
template<> ::remote::SubscribeReply* Arena::CreateMaybeMessage<::remote::SubscribeReply>(Arena*);
template<> ::remote::SubscribeRequest* Arena::CreateMaybeMessage<::remote::SubscribeRequest>(Arena*);
template<> ::remote::TxRequest* Arena::CreateMaybeMessage<::remote::TxRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace remote {

enum Event : int {
  HEADER = 0,
  PENDING_LOGS = 1,
  PENDING_BLOCK = 2,
  PENDING_TRANSACTIONS = 3,
  Event_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Event_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Event_IsValid(int value);
constexpr Event Event_MIN = HEADER;
constexpr Event Event_MAX = PENDING_TRANSACTIONS;
constexpr int Event_ARRAYSIZE = Event_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_descriptor();
template<typename T>
inline const std::string& Event_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Event>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Event_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Event_descriptor(), enum_t_value);
}
inline bool Event_Parse(
    const std::string& name, Event* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event>(
    Event_descriptor(), name, value);
}
// ===================================================================

class TxRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.TxRequest) */ {
 public:
  inline TxRequest() : TxRequest(nullptr) {};
  virtual ~TxRequest();

  TxRequest(const TxRequest& from);
  TxRequest(TxRequest&& from) noexcept
    : TxRequest() {
    *this = ::std::move(from);
  }

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxRequest& operator=(TxRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxRequest* internal_default_instance() {
    return reinterpret_cast<const TxRequest*>(
               &_TxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TxRequest& a, TxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TxRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TxRequest* New() const final {
    return CreateMaybeMessage<TxRequest>(nullptr);
  }

  TxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TxRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.TxRequest";
  }
  protected:
  explicit TxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedtxFieldNumber = 1,
  };
  // bytes signedtx = 1;
  void clear_signedtx();
  const std::string& signedtx() const;
  void set_signedtx(const std::string& value);
  void set_signedtx(std::string&& value);
  void set_signedtx(const char* value);
  void set_signedtx(const void* value, size_t size);
  std::string* mutable_signedtx();
  std::string* release_signedtx();
  void set_allocated_signedtx(std::string* signedtx);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signedtx();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signedtx(
      std::string* signedtx);
  private:
  const std::string& _internal_signedtx() const;
  void _internal_set_signedtx(const std::string& value);
  std::string* _internal_mutable_signedtx();
  public:

  // @@protoc_insertion_point(class_scope:remote.TxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signedtx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class AddReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.AddReply) */ {
 public:
  inline AddReply() : AddReply(nullptr) {};
  virtual ~AddReply();

  AddReply(const AddReply& from);
  AddReply(AddReply&& from) noexcept
    : AddReply() {
    *this = ::std::move(from);
  }

  inline AddReply& operator=(const AddReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddReply& operator=(AddReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddReply* internal_default_instance() {
    return reinterpret_cast<const AddReply*>(
               &_AddReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddReply& a, AddReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AddReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddReply* New() const final {
    return CreateMaybeMessage<AddReply>(nullptr);
  }

  AddReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddReply& from);
  void MergeFrom(const AddReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.AddReply";
  }
  protected:
  explicit AddReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // .types.H256 hash = 1;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const ::types::H256& hash() const;
  ::types::H256* release_hash();
  ::types::H256* mutable_hash();
  void set_allocated_hash(::types::H256* hash);
  private:
  const ::types::H256& _internal_hash() const;
  ::types::H256* _internal_mutable_hash();
  public:
  void unsafe_arena_set_allocated_hash(
      ::types::H256* hash);
  ::types::H256* unsafe_arena_release_hash();

  // @@protoc_insertion_point(class_scope:remote.AddReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H256* hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EtherbaseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EtherbaseRequest) */ {
 public:
  inline EtherbaseRequest() : EtherbaseRequest(nullptr) {};
  virtual ~EtherbaseRequest();

  EtherbaseRequest(const EtherbaseRequest& from);
  EtherbaseRequest(EtherbaseRequest&& from) noexcept
    : EtherbaseRequest() {
    *this = ::std::move(from);
  }

  inline EtherbaseRequest& operator=(const EtherbaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EtherbaseRequest& operator=(EtherbaseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EtherbaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EtherbaseRequest* internal_default_instance() {
    return reinterpret_cast<const EtherbaseRequest*>(
               &_EtherbaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EtherbaseRequest& a, EtherbaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EtherbaseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EtherbaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EtherbaseRequest* New() const final {
    return CreateMaybeMessage<EtherbaseRequest>(nullptr);
  }

  EtherbaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EtherbaseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EtherbaseRequest& from);
  void MergeFrom(const EtherbaseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EtherbaseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EtherbaseRequest";
  }
  protected:
  explicit EtherbaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.EtherbaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class EtherbaseReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.EtherbaseReply) */ {
 public:
  inline EtherbaseReply() : EtherbaseReply(nullptr) {};
  virtual ~EtherbaseReply();

  EtherbaseReply(const EtherbaseReply& from);
  EtherbaseReply(EtherbaseReply&& from) noexcept
    : EtherbaseReply() {
    *this = ::std::move(from);
  }

  inline EtherbaseReply& operator=(const EtherbaseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EtherbaseReply& operator=(EtherbaseReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EtherbaseReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EtherbaseReply* internal_default_instance() {
    return reinterpret_cast<const EtherbaseReply*>(
               &_EtherbaseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EtherbaseReply& a, EtherbaseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EtherbaseReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EtherbaseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EtherbaseReply* New() const final {
    return CreateMaybeMessage<EtherbaseReply>(nullptr);
  }

  EtherbaseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EtherbaseReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EtherbaseReply& from);
  void MergeFrom(const EtherbaseReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EtherbaseReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.EtherbaseReply";
  }
  protected:
  explicit EtherbaseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // .types.H160 address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:remote.EtherbaseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::types::H160* address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetVersionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NetVersionRequest) */ {
 public:
  inline NetVersionRequest() : NetVersionRequest(nullptr) {};
  virtual ~NetVersionRequest();

  NetVersionRequest(const NetVersionRequest& from);
  NetVersionRequest(NetVersionRequest&& from) noexcept
    : NetVersionRequest() {
    *this = ::std::move(from);
  }

  inline NetVersionRequest& operator=(const NetVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetVersionRequest& operator=(NetVersionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NetVersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetVersionRequest* internal_default_instance() {
    return reinterpret_cast<const NetVersionRequest*>(
               &_NetVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetVersionRequest& a, NetVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetVersionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetVersionRequest* New() const final {
    return CreateMaybeMessage<NetVersionRequest>(nullptr);
  }

  NetVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetVersionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NetVersionRequest& from);
  void MergeFrom(const NetVersionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetVersionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetVersionRequest";
  }
  protected:
  explicit NetVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.NetVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class NetVersionReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.NetVersionReply) */ {
 public:
  inline NetVersionReply() : NetVersionReply(nullptr) {};
  virtual ~NetVersionReply();

  NetVersionReply(const NetVersionReply& from);
  NetVersionReply(NetVersionReply&& from) noexcept
    : NetVersionReply() {
    *this = ::std::move(from);
  }

  inline NetVersionReply& operator=(const NetVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetVersionReply& operator=(NetVersionReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NetVersionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetVersionReply* internal_default_instance() {
    return reinterpret_cast<const NetVersionReply*>(
               &_NetVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NetVersionReply& a, NetVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NetVersionReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetVersionReply* New() const final {
    return CreateMaybeMessage<NetVersionReply>(nullptr);
  }

  NetVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetVersionReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NetVersionReply& from);
  void MergeFrom(const NetVersionReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetVersionReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.NetVersionReply";
  }
  protected:
  explicit NetVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:remote.NetVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ProtocolVersionRequest) */ {
 public:
  inline ProtocolVersionRequest() : ProtocolVersionRequest(nullptr) {};
  virtual ~ProtocolVersionRequest();

  ProtocolVersionRequest(const ProtocolVersionRequest& from);
  ProtocolVersionRequest(ProtocolVersionRequest&& from) noexcept
    : ProtocolVersionRequest() {
    *this = ::std::move(from);
  }

  inline ProtocolVersionRequest& operator=(const ProtocolVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersionRequest& operator=(ProtocolVersionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProtocolVersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolVersionRequest* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersionRequest*>(
               &_ProtocolVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProtocolVersionRequest& a, ProtocolVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProtocolVersionRequest* New() const final {
    return CreateMaybeMessage<ProtocolVersionRequest>(nullptr);
  }

  ProtocolVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolVersionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProtocolVersionRequest& from);
  void MergeFrom(const ProtocolVersionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolVersionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ProtocolVersionRequest";
  }
  protected:
  explicit ProtocolVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.ProtocolVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ProtocolVersionReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ProtocolVersionReply) */ {
 public:
  inline ProtocolVersionReply() : ProtocolVersionReply(nullptr) {};
  virtual ~ProtocolVersionReply();

  ProtocolVersionReply(const ProtocolVersionReply& from);
  ProtocolVersionReply(ProtocolVersionReply&& from) noexcept
    : ProtocolVersionReply() {
    *this = ::std::move(from);
  }

  inline ProtocolVersionReply& operator=(const ProtocolVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolVersionReply& operator=(ProtocolVersionReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProtocolVersionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolVersionReply* internal_default_instance() {
    return reinterpret_cast<const ProtocolVersionReply*>(
               &_ProtocolVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProtocolVersionReply& a, ProtocolVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolVersionReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProtocolVersionReply* New() const final {
    return CreateMaybeMessage<ProtocolVersionReply>(nullptr);
  }

  ProtocolVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolVersionReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProtocolVersionReply& from);
  void MergeFrom(const ProtocolVersionReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolVersionReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ProtocolVersionReply";
  }
  protected:
  explicit ProtocolVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:remote.ProtocolVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientVersionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ClientVersionRequest) */ {
 public:
  inline ClientVersionRequest() : ClientVersionRequest(nullptr) {};
  virtual ~ClientVersionRequest();

  ClientVersionRequest(const ClientVersionRequest& from);
  ClientVersionRequest(ClientVersionRequest&& from) noexcept
    : ClientVersionRequest() {
    *this = ::std::move(from);
  }

  inline ClientVersionRequest& operator=(const ClientVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersionRequest& operator=(ClientVersionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientVersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientVersionRequest* internal_default_instance() {
    return reinterpret_cast<const ClientVersionRequest*>(
               &_ClientVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientVersionRequest& a, ClientVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientVersionRequest* New() const final {
    return CreateMaybeMessage<ClientVersionRequest>(nullptr);
  }

  ClientVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientVersionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientVersionRequest& from);
  void MergeFrom(const ClientVersionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientVersionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ClientVersionRequest";
  }
  protected:
  explicit ClientVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.ClientVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class ClientVersionReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.ClientVersionReply) */ {
 public:
  inline ClientVersionReply() : ClientVersionReply(nullptr) {};
  virtual ~ClientVersionReply();

  ClientVersionReply(const ClientVersionReply& from);
  ClientVersionReply(ClientVersionReply&& from) noexcept
    : ClientVersionReply() {
    *this = ::std::move(from);
  }

  inline ClientVersionReply& operator=(const ClientVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientVersionReply& operator=(ClientVersionReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientVersionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientVersionReply* internal_default_instance() {
    return reinterpret_cast<const ClientVersionReply*>(
               &_ClientVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientVersionReply& a, ClientVersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientVersionReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientVersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientVersionReply* New() const final {
    return CreateMaybeMessage<ClientVersionReply>(nullptr);
  }

  ClientVersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientVersionReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientVersionReply& from);
  void MergeFrom(const ClientVersionReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientVersionReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.ClientVersionReply";
  }
  protected:
  explicit ClientVersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 1,
  };
  // string nodeName = 1;
  void clear_nodename();
  const std::string& nodename() const;
  void set_nodename(const std::string& value);
  void set_nodename(std::string&& value);
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  std::string* mutable_nodename();
  std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodename(
      std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // @@protoc_insertion_point(class_scope:remote.ClientVersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {};
  virtual ~SubscribeRequest();

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeRequest* New() const final {
    return CreateMaybeMessage<SubscribeRequest>(nullptr);
  }

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeRequest& from);
  void MergeFrom(const SubscribeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubscribeReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubscribeReply) */ {
 public:
  inline SubscribeReply() : SubscribeReply(nullptr) {};
  virtual ~SubscribeReply();

  SubscribeReply(const SubscribeReply& from);
  SubscribeReply(SubscribeReply&& from) noexcept
    : SubscribeReply() {
    *this = ::std::move(from);
  }

  inline SubscribeReply& operator=(const SubscribeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReply& operator=(SubscribeReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeReply* internal_default_instance() {
    return reinterpret_cast<const SubscribeReply*>(
               &_SubscribeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubscribeReply& a, SubscribeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeReply* New() const final {
    return CreateMaybeMessage<SubscribeReply>(nullptr);
  }

  SubscribeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeReply& from);
  void MergeFrom(const SubscribeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubscribeReply";
  }
  protected:
  explicit SubscribeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .remote.Event type = 1;
  void clear_type();
  ::remote::Event type() const;
  void set_type(::remote::Event value);
  private:
  ::remote::Event _internal_type() const;
  void _internal_set_type(::remote::Event value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubscribeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class GetWorkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.GetWorkRequest) */ {
 public:
  inline GetWorkRequest() : GetWorkRequest(nullptr) {};
  virtual ~GetWorkRequest();

  GetWorkRequest(const GetWorkRequest& from);
  GetWorkRequest(GetWorkRequest&& from) noexcept
    : GetWorkRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkRequest& operator=(const GetWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkRequest& operator=(GetWorkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetWorkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWorkRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkRequest*>(
               &_GetWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetWorkRequest& a, GetWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetWorkRequest* New() const final {
    return CreateMaybeMessage<GetWorkRequest>(nullptr);
  }

  GetWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetWorkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetWorkRequest& from);
  void MergeFrom(const GetWorkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.GetWorkRequest";
  }
  protected:
  explicit GetWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.GetWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class GetWorkReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.GetWorkReply) */ {
 public:
  inline GetWorkReply() : GetWorkReply(nullptr) {};
  virtual ~GetWorkReply();

  GetWorkReply(const GetWorkReply& from);
  GetWorkReply(GetWorkReply&& from) noexcept
    : GetWorkReply() {
    *this = ::std::move(from);
  }

  inline GetWorkReply& operator=(const GetWorkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkReply& operator=(GetWorkReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetWorkReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWorkReply* internal_default_instance() {
    return reinterpret_cast<const GetWorkReply*>(
               &_GetWorkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetWorkReply& a, GetWorkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetWorkReply* New() const final {
    return CreateMaybeMessage<GetWorkReply>(nullptr);
  }

  GetWorkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetWorkReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetWorkReply& from);
  void MergeFrom(const GetWorkReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.GetWorkReply";
  }
  protected:
  explicit GetWorkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderHashFieldNumber = 1,
    kSeedHashFieldNumber = 2,
    kTargetFieldNumber = 3,
    kBlockNumberFieldNumber = 4,
  };
  // string headerHash = 1;
  void clear_headerhash();
  const std::string& headerhash() const;
  void set_headerhash(const std::string& value);
  void set_headerhash(std::string&& value);
  void set_headerhash(const char* value);
  void set_headerhash(const char* value, size_t size);
  std::string* mutable_headerhash();
  std::string* release_headerhash();
  void set_allocated_headerhash(std::string* headerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_headerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_headerhash(
      std::string* headerhash);
  private:
  const std::string& _internal_headerhash() const;
  void _internal_set_headerhash(const std::string& value);
  std::string* _internal_mutable_headerhash();
  public:

  // string seedHash = 2;
  void clear_seedhash();
  const std::string& seedhash() const;
  void set_seedhash(const std::string& value);
  void set_seedhash(std::string&& value);
  void set_seedhash(const char* value);
  void set_seedhash(const char* value, size_t size);
  std::string* mutable_seedhash();
  std::string* release_seedhash();
  void set_allocated_seedhash(std::string* seedhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_seedhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_seedhash(
      std::string* seedhash);
  private:
  const std::string& _internal_seedhash() const;
  void _internal_set_seedhash(const std::string& value);
  std::string* _internal_mutable_seedhash();
  public:

  // string target = 3;
  void clear_target();
  const std::string& target() const;
  void set_target(const std::string& value);
  void set_target(std::string&& value);
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  std::string* mutable_target();
  std::string* release_target();
  void set_allocated_target(std::string* target);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_target();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_target(
      std::string* target);
  private:
  const std::string& _internal_target() const;
  void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // string blockNumber = 4;
  void clear_blocknumber();
  const std::string& blocknumber() const;
  void set_blocknumber(const std::string& value);
  void set_blocknumber(std::string&& value);
  void set_blocknumber(const char* value);
  void set_blocknumber(const char* value, size_t size);
  std::string* mutable_blocknumber();
  std::string* release_blocknumber();
  void set_allocated_blocknumber(std::string* blocknumber);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_blocknumber();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blocknumber(
      std::string* blocknumber);
  private:
  const std::string& _internal_blocknumber() const;
  void _internal_set_blocknumber(const std::string& value);
  std::string* _internal_mutable_blocknumber();
  public:

  // @@protoc_insertion_point(class_scope:remote.GetWorkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headerhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seedhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blocknumber_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubmitWorkRequest) */ {
 public:
  inline SubmitWorkRequest() : SubmitWorkRequest(nullptr) {};
  virtual ~SubmitWorkRequest();

  SubmitWorkRequest(const SubmitWorkRequest& from);
  SubmitWorkRequest(SubmitWorkRequest&& from) noexcept
    : SubmitWorkRequest() {
    *this = ::std::move(from);
  }

  inline SubmitWorkRequest& operator=(const SubmitWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkRequest& operator=(SubmitWorkRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmitWorkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitWorkRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkRequest*>(
               &_SubmitWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SubmitWorkRequest& a, SubmitWorkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmitWorkRequest* New() const final {
    return CreateMaybeMessage<SubmitWorkRequest>(nullptr);
  }

  SubmitWorkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmitWorkRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmitWorkRequest& from);
  void MergeFrom(const SubmitWorkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubmitWorkRequest";
  }
  protected:
  explicit SubmitWorkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockNonceFieldNumber = 1,
    kPowHashFieldNumber = 2,
    kDigestFieldNumber = 3,
  };
  // bytes blockNonce = 1;
  void clear_blocknonce();
  const std::string& blocknonce() const;
  void set_blocknonce(const std::string& value);
  void set_blocknonce(std::string&& value);
  void set_blocknonce(const char* value);
  void set_blocknonce(const void* value, size_t size);
  std::string* mutable_blocknonce();
  std::string* release_blocknonce();
  void set_allocated_blocknonce(std::string* blocknonce);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_blocknonce();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blocknonce(
      std::string* blocknonce);
  private:
  const std::string& _internal_blocknonce() const;
  void _internal_set_blocknonce(const std::string& value);
  std::string* _internal_mutable_blocknonce();
  public:

  // bytes powHash = 2;
  void clear_powhash();
  const std::string& powhash() const;
  void set_powhash(const std::string& value);
  void set_powhash(std::string&& value);
  void set_powhash(const char* value);
  void set_powhash(const void* value, size_t size);
  std::string* mutable_powhash();
  std::string* release_powhash();
  void set_allocated_powhash(std::string* powhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_powhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_powhash(
      std::string* powhash);
  private:
  const std::string& _internal_powhash() const;
  void _internal_set_powhash(const std::string& value);
  std::string* _internal_mutable_powhash();
  public:

  // bytes digest = 3;
  void clear_digest();
  const std::string& digest() const;
  void set_digest(const std::string& value);
  void set_digest(std::string&& value);
  void set_digest(const char* value);
  void set_digest(const void* value, size_t size);
  std::string* mutable_digest();
  std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_digest();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_digest(
      std::string* digest);
  private:
  const std::string& _internal_digest() const;
  void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // @@protoc_insertion_point(class_scope:remote.SubmitWorkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blocknonce_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr powhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubmitWorkReply) */ {
 public:
  inline SubmitWorkReply() : SubmitWorkReply(nullptr) {};
  virtual ~SubmitWorkReply();

  SubmitWorkReply(const SubmitWorkReply& from);
  SubmitWorkReply(SubmitWorkReply&& from) noexcept
    : SubmitWorkReply() {
    *this = ::std::move(from);
  }

  inline SubmitWorkReply& operator=(const SubmitWorkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkReply& operator=(SubmitWorkReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmitWorkReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitWorkReply* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkReply*>(
               &_SubmitWorkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SubmitWorkReply& a, SubmitWorkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitWorkReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmitWorkReply* New() const final {
    return CreateMaybeMessage<SubmitWorkReply>(nullptr);
  }

  SubmitWorkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmitWorkReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmitWorkReply& from);
  void MergeFrom(const SubmitWorkReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitWorkReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubmitWorkReply";
  }
  protected:
  explicit SubmitWorkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubmitWorkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubmitHashRateRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubmitHashRateRequest) */ {
 public:
  inline SubmitHashRateRequest() : SubmitHashRateRequest(nullptr) {};
  virtual ~SubmitHashRateRequest();

  SubmitHashRateRequest(const SubmitHashRateRequest& from);
  SubmitHashRateRequest(SubmitHashRateRequest&& from) noexcept
    : SubmitHashRateRequest() {
    *this = ::std::move(from);
  }

  inline SubmitHashRateRequest& operator=(const SubmitHashRateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitHashRateRequest& operator=(SubmitHashRateRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmitHashRateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitHashRateRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitHashRateRequest*>(
               &_SubmitHashRateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SubmitHashRateRequest& a, SubmitHashRateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitHashRateRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitHashRateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmitHashRateRequest* New() const final {
    return CreateMaybeMessage<SubmitHashRateRequest>(nullptr);
  }

  SubmitHashRateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmitHashRateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmitHashRateRequest& from);
  void MergeFrom(const SubmitHashRateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitHashRateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubmitHashRateRequest";
  }
  protected:
  explicit SubmitHashRateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kRateFieldNumber = 1,
  };
  // bytes id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 rate = 1;
  void clear_rate();
  ::PROTOBUF_NAMESPACE_ID::uint64 rate() const;
  void set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rate() const;
  void _internal_set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubmitHashRateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class SubmitHashRateReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SubmitHashRateReply) */ {
 public:
  inline SubmitHashRateReply() : SubmitHashRateReply(nullptr) {};
  virtual ~SubmitHashRateReply();

  SubmitHashRateReply(const SubmitHashRateReply& from);
  SubmitHashRateReply(SubmitHashRateReply&& from) noexcept
    : SubmitHashRateReply() {
    *this = ::std::move(from);
  }

  inline SubmitHashRateReply& operator=(const SubmitHashRateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitHashRateReply& operator=(SubmitHashRateReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmitHashRateReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmitHashRateReply* internal_default_instance() {
    return reinterpret_cast<const SubmitHashRateReply*>(
               &_SubmitHashRateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SubmitHashRateReply& a, SubmitHashRateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitHashRateReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitHashRateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmitHashRateReply* New() const final {
    return CreateMaybeMessage<SubmitHashRateReply>(nullptr);
  }

  SubmitHashRateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmitHashRateReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmitHashRateReply& from);
  void MergeFrom(const SubmitHashRateReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitHashRateReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SubmitHashRateReply";
  }
  protected:
  explicit SubmitHashRateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.SubmitHashRateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class GetHashRateRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.GetHashRateRequest) */ {
 public:
  inline GetHashRateRequest() : GetHashRateRequest(nullptr) {};
  virtual ~GetHashRateRequest();

  GetHashRateRequest(const GetHashRateRequest& from);
  GetHashRateRequest(GetHashRateRequest&& from) noexcept
    : GetHashRateRequest() {
    *this = ::std::move(from);
  }

  inline GetHashRateRequest& operator=(const GetHashRateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHashRateRequest& operator=(GetHashRateRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetHashRateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetHashRateRequest* internal_default_instance() {
    return reinterpret_cast<const GetHashRateRequest*>(
               &_GetHashRateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetHashRateRequest& a, GetHashRateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHashRateRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHashRateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetHashRateRequest* New() const final {
    return CreateMaybeMessage<GetHashRateRequest>(nullptr);
  }

  GetHashRateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetHashRateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetHashRateRequest& from);
  void MergeFrom(const GetHashRateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHashRateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.GetHashRateRequest";
  }
  protected:
  explicit GetHashRateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.GetHashRateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class GetHashRateReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.GetHashRateReply) */ {
 public:
  inline GetHashRateReply() : GetHashRateReply(nullptr) {};
  virtual ~GetHashRateReply();

  GetHashRateReply(const GetHashRateReply& from);
  GetHashRateReply(GetHashRateReply&& from) noexcept
    : GetHashRateReply() {
    *this = ::std::move(from);
  }

  inline GetHashRateReply& operator=(const GetHashRateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHashRateReply& operator=(GetHashRateReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetHashRateReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetHashRateReply* internal_default_instance() {
    return reinterpret_cast<const GetHashRateReply*>(
               &_GetHashRateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetHashRateReply& a, GetHashRateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHashRateReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHashRateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetHashRateReply* New() const final {
    return CreateMaybeMessage<GetHashRateReply>(nullptr);
  }

  GetHashRateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetHashRateReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetHashRateReply& from);
  void MergeFrom(const GetHashRateReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHashRateReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.GetHashRateReply";
  }
  protected:
  explicit GetHashRateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashRateFieldNumber = 1,
  };
  // uint64 hashRate = 1;
  void clear_hashrate();
  ::PROTOBUF_NAMESPACE_ID::uint64 hashrate() const;
  void set_hashrate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_hashrate() const;
  void _internal_set_hashrate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:remote.GetHashRateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 hashrate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class MiningRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.MiningRequest) */ {
 public:
  inline MiningRequest() : MiningRequest(nullptr) {};
  virtual ~MiningRequest();

  MiningRequest(const MiningRequest& from);
  MiningRequest(MiningRequest&& from) noexcept
    : MiningRequest() {
    *this = ::std::move(from);
  }

  inline MiningRequest& operator=(const MiningRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiningRequest& operator=(MiningRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MiningRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MiningRequest* internal_default_instance() {
    return reinterpret_cast<const MiningRequest*>(
               &_MiningRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MiningRequest& a, MiningRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MiningRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiningRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MiningRequest* New() const final {
    return CreateMaybeMessage<MiningRequest>(nullptr);
  }

  MiningRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MiningRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MiningRequest& from);
  void MergeFrom(const MiningRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MiningRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.MiningRequest";
  }
  protected:
  explicit MiningRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.MiningRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// -------------------------------------------------------------------

class MiningReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.MiningReply) */ {
 public:
  inline MiningReply() : MiningReply(nullptr) {};
  virtual ~MiningReply();

  MiningReply(const MiningReply& from);
  MiningReply(MiningReply&& from) noexcept
    : MiningReply() {
    *this = ::std::move(from);
  }

  inline MiningReply& operator=(const MiningReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiningReply& operator=(MiningReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MiningReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MiningReply* internal_default_instance() {
    return reinterpret_cast<const MiningReply*>(
               &_MiningReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MiningReply& a, MiningReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MiningReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiningReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MiningReply* New() const final {
    return CreateMaybeMessage<MiningReply>(nullptr);
  }

  MiningReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MiningReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MiningReply& from);
  void MergeFrom(const MiningReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MiningReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.MiningReply";
  }
  protected:
  explicit MiningReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_remote_2fethbackend_2eproto);
    return ::descriptor_table_remote_2fethbackend_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kRunningFieldNumber = 2,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool running = 2;
  void clear_running();
  bool running() const;
  void set_running(bool value);
  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.MiningReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enabled_;
  bool running_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_remote_2fethbackend_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TxRequest

// bytes signedtx = 1;
inline void TxRequest::clear_signedtx() {
  signedtx_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TxRequest::signedtx() const {
  // @@protoc_insertion_point(field_get:remote.TxRequest.signedtx)
  return _internal_signedtx();
}
inline void TxRequest::set_signedtx(const std::string& value) {
  _internal_set_signedtx(value);
  // @@protoc_insertion_point(field_set:remote.TxRequest.signedtx)
}
inline std::string* TxRequest::mutable_signedtx() {
  // @@protoc_insertion_point(field_mutable:remote.TxRequest.signedtx)
  return _internal_mutable_signedtx();
}
inline const std::string& TxRequest::_internal_signedtx() const {
  return signedtx_.Get();
}
inline void TxRequest::_internal_set_signedtx(const std::string& value) {
  
  signedtx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TxRequest::set_signedtx(std::string&& value) {
  
  signedtx_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.TxRequest.signedtx)
}
inline void TxRequest::set_signedtx(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signedtx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.TxRequest.signedtx)
}
inline void TxRequest::set_signedtx(const void* value,
    size_t size) {
  
  signedtx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.TxRequest.signedtx)
}
inline std::string* TxRequest::_internal_mutable_signedtx() {
  
  return signedtx_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TxRequest::release_signedtx() {
  // @@protoc_insertion_point(field_release:remote.TxRequest.signedtx)
  return signedtx_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TxRequest::set_allocated_signedtx(std::string* signedtx) {
  if (signedtx != nullptr) {
    
  } else {
    
  }
  signedtx_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signedtx,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.TxRequest.signedtx)
}
inline std::string* TxRequest::unsafe_arena_release_signedtx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.TxRequest.signedtx)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signedtx_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TxRequest::unsafe_arena_set_allocated_signedtx(
    std::string* signedtx) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signedtx != nullptr) {
    
  } else {
    
  }
  signedtx_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signedtx, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.TxRequest.signedtx)
}

// -------------------------------------------------------------------

// AddReply

// .types.H256 hash = 1;
inline bool AddReply::_internal_has_hash() const {
  return this != internal_default_instance() && hash_ != nullptr;
}
inline bool AddReply::has_hash() const {
  return _internal_has_hash();
}
inline const ::types::H256& AddReply::_internal_hash() const {
  const ::types::H256* p = hash_;
  return p != nullptr ? *p : *reinterpret_cast<const ::types::H256*>(
      &::types::_H256_default_instance_);
}
inline const ::types::H256& AddReply::hash() const {
  // @@protoc_insertion_point(field_get:remote.AddReply.hash)
  return _internal_hash();
}
inline void AddReply::unsafe_arena_set_allocated_hash(
    ::types::H256* hash) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_);
  }
  hash_ = hash;
  if (hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.AddReply.hash)
}
inline ::types::H256* AddReply::release_hash() {
  auto temp = unsafe_arena_release_hash();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H256* AddReply::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_release:remote.AddReply.hash)
  
  ::types::H256* temp = hash_;
  hash_ = nullptr;
  return temp;
}
inline ::types::H256* AddReply::_internal_mutable_hash() {
  
  if (hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArena());
    hash_ = p;
  }
  return hash_;
}
inline ::types::H256* AddReply::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:remote.AddReply.hash)
  return _internal_mutable_hash();
}
inline void AddReply::set_allocated_hash(::types::H256* hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_);
  }
  if (hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash)->GetArena();
    if (message_arena != submessage_arena) {
      hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash, submessage_arena);
    }
    
  } else {
    
  }
  hash_ = hash;
  // @@protoc_insertion_point(field_set_allocated:remote.AddReply.hash)
}

// -------------------------------------------------------------------

// EtherbaseRequest

// -------------------------------------------------------------------

// EtherbaseReply

// .types.H160 address = 1;
inline bool EtherbaseReply::_internal_has_address() const {
  return this != internal_default_instance() && address_ != nullptr;
}
inline bool EtherbaseReply::has_address() const {
  return _internal_has_address();
}
inline const ::types::H160& EtherbaseReply::_internal_address() const {
  const ::types::H160* p = address_;
  return p != nullptr ? *p : *reinterpret_cast<const ::types::H160*>(
      &::types::_H160_default_instance_);
}
inline const ::types::H160& EtherbaseReply::address() const {
  // @@protoc_insertion_point(field_get:remote.EtherbaseReply.address)
  return _internal_address();
}
inline void EtherbaseReply::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.EtherbaseReply.address)
}
inline ::types::H160* EtherbaseReply::release_address() {
  auto temp = unsafe_arena_release_address();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::types::H160* EtherbaseReply::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:remote.EtherbaseReply.address)
  
  ::types::H160* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::types::H160* EtherbaseReply::_internal_mutable_address() {
  
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArena());
    address_ = p;
  }
  return address_;
}
inline ::types::H160* EtherbaseReply::mutable_address() {
  // @@protoc_insertion_point(field_mutable:remote.EtherbaseReply.address)
  return _internal_mutable_address();
}
inline void EtherbaseReply::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address)->GetArena();
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:remote.EtherbaseReply.address)
}

// -------------------------------------------------------------------

// NetVersionRequest

// -------------------------------------------------------------------

// NetVersionReply

// uint64 id = 1;
inline void NetVersionReply::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NetVersionReply::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NetVersionReply::id() const {
  // @@protoc_insertion_point(field_get:remote.NetVersionReply.id)
  return _internal_id();
}
inline void NetVersionReply::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void NetVersionReply::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.NetVersionReply.id)
}

// -------------------------------------------------------------------

// ProtocolVersionRequest

// -------------------------------------------------------------------

// ProtocolVersionReply

// uint64 id = 1;
inline void ProtocolVersionReply::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ProtocolVersionReply::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ProtocolVersionReply::id() const {
  // @@protoc_insertion_point(field_get:remote.ProtocolVersionReply.id)
  return _internal_id();
}
inline void ProtocolVersionReply::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void ProtocolVersionReply::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.ProtocolVersionReply.id)
}

// -------------------------------------------------------------------

// ClientVersionRequest

// -------------------------------------------------------------------

// ClientVersionReply

// string nodeName = 1;
inline void ClientVersionReply::clear_nodename() {
  nodename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ClientVersionReply::nodename() const {
  // @@protoc_insertion_point(field_get:remote.ClientVersionReply.nodeName)
  return _internal_nodename();
}
inline void ClientVersionReply::set_nodename(const std::string& value) {
  _internal_set_nodename(value);
  // @@protoc_insertion_point(field_set:remote.ClientVersionReply.nodeName)
}
inline std::string* ClientVersionReply::mutable_nodename() {
  // @@protoc_insertion_point(field_mutable:remote.ClientVersionReply.nodeName)
  return _internal_mutable_nodename();
}
inline const std::string& ClientVersionReply::_internal_nodename() const {
  return nodename_.Get();
}
inline void ClientVersionReply::_internal_set_nodename(const std::string& value) {
  
  nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ClientVersionReply::set_nodename(std::string&& value) {
  
  nodename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.ClientVersionReply.nodeName)
}
inline void ClientVersionReply::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.ClientVersionReply.nodeName)
}
inline void ClientVersionReply::set_nodename(const char* value,
    size_t size) {
  
  nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.ClientVersionReply.nodeName)
}
inline std::string* ClientVersionReply::_internal_mutable_nodename() {
  
  return nodename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ClientVersionReply::release_nodename() {
  // @@protoc_insertion_point(field_release:remote.ClientVersionReply.nodeName)
  return nodename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientVersionReply::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    
  } else {
    
  }
  nodename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.ClientVersionReply.nodeName)
}
inline std::string* ClientVersionReply::unsafe_arena_release_nodename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.ClientVersionReply.nodeName)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return nodename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ClientVersionReply::unsafe_arena_set_allocated_nodename(
    std::string* nodename) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodename != nullptr) {
    
  } else {
    
  }
  nodename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodename, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.ClientVersionReply.nodeName)
}

// -------------------------------------------------------------------

// SubscribeRequest

// -------------------------------------------------------------------

// SubscribeReply

// .remote.Event type = 1;
inline void SubscribeReply::clear_type() {
  type_ = 0;
}
inline ::remote::Event SubscribeReply::_internal_type() const {
  return static_cast< ::remote::Event >(type_);
}
inline ::remote::Event SubscribeReply::type() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeReply.type)
  return _internal_type();
}
inline void SubscribeReply::_internal_set_type(::remote::Event value) {
  
  type_ = value;
}
inline void SubscribeReply::set_type(::remote::Event value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeReply.type)
}

// bytes data = 2;
inline void SubscribeReply::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SubscribeReply::data() const {
  // @@protoc_insertion_point(field_get:remote.SubscribeReply.data)
  return _internal_data();
}
inline void SubscribeReply::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:remote.SubscribeReply.data)
}
inline std::string* SubscribeReply::mutable_data() {
  // @@protoc_insertion_point(field_mutable:remote.SubscribeReply.data)
  return _internal_mutable_data();
}
inline const std::string& SubscribeReply::_internal_data() const {
  return data_.Get();
}
inline void SubscribeReply::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeReply::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.SubscribeReply.data)
}
inline void SubscribeReply::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.SubscribeReply.data)
}
inline void SubscribeReply::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.SubscribeReply.data)
}
inline std::string* SubscribeReply::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeReply::release_data() {
  // @@protoc_insertion_point(field_release:remote.SubscribeReply.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeReply::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.SubscribeReply.data)
}
inline std::string* SubscribeReply::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.SubscribeReply.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubscribeReply::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubscribeReply.data)
}

// -------------------------------------------------------------------

// GetWorkRequest

// -------------------------------------------------------------------

// GetWorkReply

// string headerHash = 1;
inline void GetWorkReply::clear_headerhash() {
  headerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetWorkReply::headerhash() const {
  // @@protoc_insertion_point(field_get:remote.GetWorkReply.headerHash)
  return _internal_headerhash();
}
inline void GetWorkReply::set_headerhash(const std::string& value) {
  _internal_set_headerhash(value);
  // @@protoc_insertion_point(field_set:remote.GetWorkReply.headerHash)
}
inline std::string* GetWorkReply::mutable_headerhash() {
  // @@protoc_insertion_point(field_mutable:remote.GetWorkReply.headerHash)
  return _internal_mutable_headerhash();
}
inline const std::string& GetWorkReply::_internal_headerhash() const {
  return headerhash_.Get();
}
inline void GetWorkReply::_internal_set_headerhash(const std::string& value) {
  
  headerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetWorkReply::set_headerhash(std::string&& value) {
  
  headerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.GetWorkReply.headerHash)
}
inline void GetWorkReply::set_headerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  headerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.GetWorkReply.headerHash)
}
inline void GetWorkReply::set_headerhash(const char* value,
    size_t size) {
  
  headerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.GetWorkReply.headerHash)
}
inline std::string* GetWorkReply::_internal_mutable_headerhash() {
  
  return headerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetWorkReply::release_headerhash() {
  // @@protoc_insertion_point(field_release:remote.GetWorkReply.headerHash)
  return headerhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetWorkReply::set_allocated_headerhash(std::string* headerhash) {
  if (headerhash != nullptr) {
    
  } else {
    
  }
  headerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.GetWorkReply.headerHash)
}
inline std::string* GetWorkReply::unsafe_arena_release_headerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.GetWorkReply.headerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return headerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetWorkReply::unsafe_arena_set_allocated_headerhash(
    std::string* headerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (headerhash != nullptr) {
    
  } else {
    
  }
  headerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      headerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.GetWorkReply.headerHash)
}

// string seedHash = 2;
inline void GetWorkReply::clear_seedhash() {
  seedhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetWorkReply::seedhash() const {
  // @@protoc_insertion_point(field_get:remote.GetWorkReply.seedHash)
  return _internal_seedhash();
}
inline void GetWorkReply::set_seedhash(const std::string& value) {
  _internal_set_seedhash(value);
  // @@protoc_insertion_point(field_set:remote.GetWorkReply.seedHash)
}
inline std::string* GetWorkReply::mutable_seedhash() {
  // @@protoc_insertion_point(field_mutable:remote.GetWorkReply.seedHash)
  return _internal_mutable_seedhash();
}
inline const std::string& GetWorkReply::_internal_seedhash() const {
  return seedhash_.Get();
}
inline void GetWorkReply::_internal_set_seedhash(const std::string& value) {
  
  seedhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetWorkReply::set_seedhash(std::string&& value) {
  
  seedhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.GetWorkReply.seedHash)
}
inline void GetWorkReply::set_seedhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  seedhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.GetWorkReply.seedHash)
}
inline void GetWorkReply::set_seedhash(const char* value,
    size_t size) {
  
  seedhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.GetWorkReply.seedHash)
}
inline std::string* GetWorkReply::_internal_mutable_seedhash() {
  
  return seedhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetWorkReply::release_seedhash() {
  // @@protoc_insertion_point(field_release:remote.GetWorkReply.seedHash)
  return seedhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetWorkReply::set_allocated_seedhash(std::string* seedhash) {
  if (seedhash != nullptr) {
    
  } else {
    
  }
  seedhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), seedhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.GetWorkReply.seedHash)
}
inline std::string* GetWorkReply::unsafe_arena_release_seedhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.GetWorkReply.seedHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return seedhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetWorkReply::unsafe_arena_set_allocated_seedhash(
    std::string* seedhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (seedhash != nullptr) {
    
  } else {
    
  }
  seedhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      seedhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.GetWorkReply.seedHash)
}

// string target = 3;
inline void GetWorkReply::clear_target() {
  target_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetWorkReply::target() const {
  // @@protoc_insertion_point(field_get:remote.GetWorkReply.target)
  return _internal_target();
}
inline void GetWorkReply::set_target(const std::string& value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:remote.GetWorkReply.target)
}
inline std::string* GetWorkReply::mutable_target() {
  // @@protoc_insertion_point(field_mutable:remote.GetWorkReply.target)
  return _internal_mutable_target();
}
inline const std::string& GetWorkReply::_internal_target() const {
  return target_.Get();
}
inline void GetWorkReply::_internal_set_target(const std::string& value) {
  
  target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetWorkReply::set_target(std::string&& value) {
  
  target_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.GetWorkReply.target)
}
inline void GetWorkReply::set_target(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.GetWorkReply.target)
}
inline void GetWorkReply::set_target(const char* value,
    size_t size) {
  
  target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.GetWorkReply.target)
}
inline std::string* GetWorkReply::_internal_mutable_target() {
  
  return target_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetWorkReply::release_target() {
  // @@protoc_insertion_point(field_release:remote.GetWorkReply.target)
  return target_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetWorkReply::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    
  } else {
    
  }
  target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.GetWorkReply.target)
}
inline std::string* GetWorkReply::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.GetWorkReply.target)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return target_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetWorkReply::unsafe_arena_set_allocated_target(
    std::string* target) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (target != nullptr) {
    
  } else {
    
  }
  target_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      target, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.GetWorkReply.target)
}

// string blockNumber = 4;
inline void GetWorkReply::clear_blocknumber() {
  blocknumber_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetWorkReply::blocknumber() const {
  // @@protoc_insertion_point(field_get:remote.GetWorkReply.blockNumber)
  return _internal_blocknumber();
}
inline void GetWorkReply::set_blocknumber(const std::string& value) {
  _internal_set_blocknumber(value);
  // @@protoc_insertion_point(field_set:remote.GetWorkReply.blockNumber)
}
inline std::string* GetWorkReply::mutable_blocknumber() {
  // @@protoc_insertion_point(field_mutable:remote.GetWorkReply.blockNumber)
  return _internal_mutable_blocknumber();
}
inline const std::string& GetWorkReply::_internal_blocknumber() const {
  return blocknumber_.Get();
}
inline void GetWorkReply::_internal_set_blocknumber(const std::string& value) {
  
  blocknumber_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetWorkReply::set_blocknumber(std::string&& value) {
  
  blocknumber_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.GetWorkReply.blockNumber)
}
inline void GetWorkReply::set_blocknumber(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blocknumber_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.GetWorkReply.blockNumber)
}
inline void GetWorkReply::set_blocknumber(const char* value,
    size_t size) {
  
  blocknumber_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.GetWorkReply.blockNumber)
}
inline std::string* GetWorkReply::_internal_mutable_blocknumber() {
  
  return blocknumber_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetWorkReply::release_blocknumber() {
  // @@protoc_insertion_point(field_release:remote.GetWorkReply.blockNumber)
  return blocknumber_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetWorkReply::set_allocated_blocknumber(std::string* blocknumber) {
  if (blocknumber != nullptr) {
    
  } else {
    
  }
  blocknumber_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blocknumber,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.GetWorkReply.blockNumber)
}
inline std::string* GetWorkReply::unsafe_arena_release_blocknumber() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.GetWorkReply.blockNumber)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return blocknumber_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetWorkReply::unsafe_arena_set_allocated_blocknumber(
    std::string* blocknumber) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (blocknumber != nullptr) {
    
  } else {
    
  }
  blocknumber_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      blocknumber, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.GetWorkReply.blockNumber)
}

// -------------------------------------------------------------------

// SubmitWorkRequest

// bytes blockNonce = 1;
inline void SubmitWorkRequest::clear_blocknonce() {
  blocknonce_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SubmitWorkRequest::blocknonce() const {
  // @@protoc_insertion_point(field_get:remote.SubmitWorkRequest.blockNonce)
  return _internal_blocknonce();
}
inline void SubmitWorkRequest::set_blocknonce(const std::string& value) {
  _internal_set_blocknonce(value);
  // @@protoc_insertion_point(field_set:remote.SubmitWorkRequest.blockNonce)
}
inline std::string* SubmitWorkRequest::mutable_blocknonce() {
  // @@protoc_insertion_point(field_mutable:remote.SubmitWorkRequest.blockNonce)
  return _internal_mutable_blocknonce();
}
inline const std::string& SubmitWorkRequest::_internal_blocknonce() const {
  return blocknonce_.Get();
}
inline void SubmitWorkRequest::_internal_set_blocknonce(const std::string& value) {
  
  blocknonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubmitWorkRequest::set_blocknonce(std::string&& value) {
  
  blocknonce_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.SubmitWorkRequest.blockNonce)
}
inline void SubmitWorkRequest::set_blocknonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blocknonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.SubmitWorkRequest.blockNonce)
}
inline void SubmitWorkRequest::set_blocknonce(const void* value,
    size_t size) {
  
  blocknonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.SubmitWorkRequest.blockNonce)
}
inline std::string* SubmitWorkRequest::_internal_mutable_blocknonce() {
  
  return blocknonce_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubmitWorkRequest::release_blocknonce() {
  // @@protoc_insertion_point(field_release:remote.SubmitWorkRequest.blockNonce)
  return blocknonce_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubmitWorkRequest::set_allocated_blocknonce(std::string* blocknonce) {
  if (blocknonce != nullptr) {
    
  } else {
    
  }
  blocknonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blocknonce,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.SubmitWorkRequest.blockNonce)
}
inline std::string* SubmitWorkRequest::unsafe_arena_release_blocknonce() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.SubmitWorkRequest.blockNonce)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return blocknonce_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubmitWorkRequest::unsafe_arena_set_allocated_blocknonce(
    std::string* blocknonce) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (blocknonce != nullptr) {
    
  } else {
    
  }
  blocknonce_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      blocknonce, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubmitWorkRequest.blockNonce)
}

// bytes powHash = 2;
inline void SubmitWorkRequest::clear_powhash() {
  powhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SubmitWorkRequest::powhash() const {
  // @@protoc_insertion_point(field_get:remote.SubmitWorkRequest.powHash)
  return _internal_powhash();
}
inline void SubmitWorkRequest::set_powhash(const std::string& value) {
  _internal_set_powhash(value);
  // @@protoc_insertion_point(field_set:remote.SubmitWorkRequest.powHash)
}
inline std::string* SubmitWorkRequest::mutable_powhash() {
  // @@protoc_insertion_point(field_mutable:remote.SubmitWorkRequest.powHash)
  return _internal_mutable_powhash();
}
inline const std::string& SubmitWorkRequest::_internal_powhash() const {
  return powhash_.Get();
}
inline void SubmitWorkRequest::_internal_set_powhash(const std::string& value) {
  
  powhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubmitWorkRequest::set_powhash(std::string&& value) {
  
  powhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.SubmitWorkRequest.powHash)
}
inline void SubmitWorkRequest::set_powhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  powhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.SubmitWorkRequest.powHash)
}
inline void SubmitWorkRequest::set_powhash(const void* value,
    size_t size) {
  
  powhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.SubmitWorkRequest.powHash)
}
inline std::string* SubmitWorkRequest::_internal_mutable_powhash() {
  
  return powhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubmitWorkRequest::release_powhash() {
  // @@protoc_insertion_point(field_release:remote.SubmitWorkRequest.powHash)
  return powhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubmitWorkRequest::set_allocated_powhash(std::string* powhash) {
  if (powhash != nullptr) {
    
  } else {
    
  }
  powhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), powhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.SubmitWorkRequest.powHash)
}
inline std::string* SubmitWorkRequest::unsafe_arena_release_powhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.SubmitWorkRequest.powHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return powhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubmitWorkRequest::unsafe_arena_set_allocated_powhash(
    std::string* powhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (powhash != nullptr) {
    
  } else {
    
  }
  powhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      powhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubmitWorkRequest.powHash)
}

// bytes digest = 3;
inline void SubmitWorkRequest::clear_digest() {
  digest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SubmitWorkRequest::digest() const {
  // @@protoc_insertion_point(field_get:remote.SubmitWorkRequest.digest)
  return _internal_digest();
}
inline void SubmitWorkRequest::set_digest(const std::string& value) {
  _internal_set_digest(value);
  // @@protoc_insertion_point(field_set:remote.SubmitWorkRequest.digest)
}
inline std::string* SubmitWorkRequest::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:remote.SubmitWorkRequest.digest)
  return _internal_mutable_digest();
}
inline const std::string& SubmitWorkRequest::_internal_digest() const {
  return digest_.Get();
}
inline void SubmitWorkRequest::_internal_set_digest(const std::string& value) {
  
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubmitWorkRequest::set_digest(std::string&& value) {
  
  digest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.SubmitWorkRequest.digest)
}
inline void SubmitWorkRequest::set_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.SubmitWorkRequest.digest)
}
inline void SubmitWorkRequest::set_digest(const void* value,
    size_t size) {
  
  digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.SubmitWorkRequest.digest)
}
inline std::string* SubmitWorkRequest::_internal_mutable_digest() {
  
  return digest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubmitWorkRequest::release_digest() {
  // @@protoc_insertion_point(field_release:remote.SubmitWorkRequest.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubmitWorkRequest::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.SubmitWorkRequest.digest)
}
inline std::string* SubmitWorkRequest::unsafe_arena_release_digest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.SubmitWorkRequest.digest)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return digest_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubmitWorkRequest::unsafe_arena_set_allocated_digest(
    std::string* digest) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      digest, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubmitWorkRequest.digest)
}

// -------------------------------------------------------------------

// SubmitWorkReply

// bool ok = 1;
inline void SubmitWorkReply::clear_ok() {
  ok_ = false;
}
inline bool SubmitWorkReply::_internal_ok() const {
  return ok_;
}
inline bool SubmitWorkReply::ok() const {
  // @@protoc_insertion_point(field_get:remote.SubmitWorkReply.ok)
  return _internal_ok();
}
inline void SubmitWorkReply::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void SubmitWorkReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remote.SubmitWorkReply.ok)
}

// -------------------------------------------------------------------

// SubmitHashRateRequest

// uint64 rate = 1;
inline void SubmitHashRateRequest::clear_rate() {
  rate_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SubmitHashRateRequest::_internal_rate() const {
  return rate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SubmitHashRateRequest::rate() const {
  // @@protoc_insertion_point(field_get:remote.SubmitHashRateRequest.rate)
  return _internal_rate();
}
inline void SubmitHashRateRequest::_internal_set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  rate_ = value;
}
inline void SubmitHashRateRequest::set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:remote.SubmitHashRateRequest.rate)
}

// bytes id = 2;
inline void SubmitHashRateRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SubmitHashRateRequest::id() const {
  // @@protoc_insertion_point(field_get:remote.SubmitHashRateRequest.id)
  return _internal_id();
}
inline void SubmitHashRateRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remote.SubmitHashRateRequest.id)
}
inline std::string* SubmitHashRateRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:remote.SubmitHashRateRequest.id)
  return _internal_mutable_id();
}
inline const std::string& SubmitHashRateRequest::_internal_id() const {
  return id_.Get();
}
inline void SubmitHashRateRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubmitHashRateRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:remote.SubmitHashRateRequest.id)
}
inline void SubmitHashRateRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:remote.SubmitHashRateRequest.id)
}
inline void SubmitHashRateRequest::set_id(const void* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:remote.SubmitHashRateRequest.id)
}
inline std::string* SubmitHashRateRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubmitHashRateRequest::release_id() {
  // @@protoc_insertion_point(field_release:remote.SubmitHashRateRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubmitHashRateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:remote.SubmitHashRateRequest.id)
}
inline std::string* SubmitHashRateRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:remote.SubmitHashRateRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubmitHashRateRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.SubmitHashRateRequest.id)
}

// -------------------------------------------------------------------

// SubmitHashRateReply

// bool ok = 1;
inline void SubmitHashRateReply::clear_ok() {
  ok_ = false;
}
inline bool SubmitHashRateReply::_internal_ok() const {
  return ok_;
}
inline bool SubmitHashRateReply::ok() const {
  // @@protoc_insertion_point(field_get:remote.SubmitHashRateReply.ok)
  return _internal_ok();
}
inline void SubmitHashRateReply::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void SubmitHashRateReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remote.SubmitHashRateReply.ok)
}

// -------------------------------------------------------------------

// GetHashRateRequest

// -------------------------------------------------------------------

// GetHashRateReply

// uint64 hashRate = 1;
inline void GetHashRateReply::clear_hashrate() {
  hashrate_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetHashRateReply::_internal_hashrate() const {
  return hashrate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetHashRateReply::hashrate() const {
  // @@protoc_insertion_point(field_get:remote.GetHashRateReply.hashRate)
  return _internal_hashrate();
}
inline void GetHashRateReply::_internal_set_hashrate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  hashrate_ = value;
}
inline void GetHashRateReply::set_hashrate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_hashrate(value);
  // @@protoc_insertion_point(field_set:remote.GetHashRateReply.hashRate)
}

// -------------------------------------------------------------------

// MiningRequest

// -------------------------------------------------------------------

// MiningReply

// bool enabled = 1;
inline void MiningReply::clear_enabled() {
  enabled_ = false;
}
inline bool MiningReply::_internal_enabled() const {
  return enabled_;
}
inline bool MiningReply::enabled() const {
  // @@protoc_insertion_point(field_get:remote.MiningReply.enabled)
  return _internal_enabled();
}
inline void MiningReply::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void MiningReply::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:remote.MiningReply.enabled)
}

// bool running = 2;
inline void MiningReply::clear_running() {
  running_ = false;
}
inline bool MiningReply::_internal_running() const {
  return running_;
}
inline bool MiningReply::running() const {
  // @@protoc_insertion_point(field_get:remote.MiningReply.running)
  return _internal_running();
}
inline void MiningReply::_internal_set_running(bool value) {
  
  running_ = value;
}
inline void MiningReply::set_running(bool value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:remote.MiningReply.running)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::remote::Event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Event>() {
  return ::remote::Event_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remote_2fethbackend_2eproto
